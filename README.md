### How JVM works (Classloader)**
Набор операций, на основе которых работает ClassLoader:

- Виртуальная машина проверяет, загружен ли класс или нет, всякий раз, когда он сталкивается с классом.
- В случае, когда класс загружен, JVM продолжает выполнение класса, но когда класс не загружен, JVM просит подсистему ClassLoader загрузить этот конкретный класс. После этого подсистема передает управление Application ClassLoader.
- Затем Application делегирует запрос Extension, которое затем передает запрос Bootstrap .
- Теперь Bootstrap ищет в пути Bootstrap classpath, чтобы проверить, доступен ли класс или нет. Если класс доступен, он загружается, в противном случае запрос снова передается в Extension.
- Extension проверяет класс в расширении classpath. Если класс доступен, он загружается, в противном случае запрос снова передается в Application.
- Наконец, Application ищет класс в пути к классам приложения. Если класс доступен, то загружается, иначе вы увидите исключение ClassNotFoundException.
**Итак, при запуске программы загружается:**
- класс JvmComprehension, String, 
- 1 строка кода - загружается класс Integer, 
- 2 строка кода - класс Object, 
- 3 строка - класс Integer уже загружен, 
- 4 строка - никаких классов нет, 
- 5 строка- класс Integer уже загружен, 
- 6 строка - загружается класс System, 
- 7 строка -класс System уже загружен. 

** Начинает работать с файлом .class (bytecode). В нашем случаем подгружается сам класс JvmComprehension и все классы, которые в нем есть:String, Integer,Object,System.
Итак, Classloader загрузил все что нашел из анализируемого класса JvmComprehension 
### Что же происходит во время подгрузки данных Classloaderом
Linking (связывание):
1. Verify (проверка на то, что данная программа компилируемая, в ней нет синтаксических ошибок).
В нашем случае проверяется класс JvmComprehension и его методы (все строки с 1-7)
2. Prepare (подготовка примитивов в статических полях). В нашем случае этого нет.
3. Resolve (разрешение символьных ссылок). В случае если были бы какие -либо импортируемые данные из других пакетов,
например, java.util.Scanner, они подгружались бы, но в нашем коде этого нет. Следовательно подгружаться ничего не будет.
### Memory в Java
Память в Java состоит из трех компонентов: 
- куча (Heap space), 
- стек (Stack space)
- метапространство (Metaspace):

Итак,
Metaspace: тут Java хранит неизменяемую информацию программы, например классы.
Heap space: в этой области хранится изменяемый контент.
Stack space: в стеке хранятся переменные, созданные в методах, и ссылки на переменные.

**Получается, все классы, которые загрузил Classloader, хранится теперь в Metaspace**

Что получается в нашем случае:
![Memory](src/main/java/Области памяти.jpg)
**Итак, как сохраняются данные в Stack memory и heap:**
- В момент вызова метода main, создается фрейм (кадр) в стеке (изображен на картинке)
и туда сохраняются данные 1 строки
- 2 строка - В этот же фрейм сохраняется ссылка на объект о, т.е. о,
сам объект (Object) сохраняется в heap
- 3 строка - В этот же фрейм сохраняется ссылка на объект ii, а сам Integer
сохраняется в heap
- 4 строка - при вызове метода  printAll, создается новый фрейм в стеке и
там сохраняются ссылки на переданные данные:o,ii, сами же объекты хранятся 
в heap, т.е. Object,Integer, int является примитивным типом, он хранится с данными 
в самом стеке.
- 5 строка -В этот же фрейм сохраняется ссылка на объект ii, а сам Integer
  уже сохранен в heap.
- 6 строка - создается новый фрейм в стеке и туда передается ссылка на o,ii и данные int i, сам System сохраняется в heap.
- 7 строка - создается новый фрейм в стеке и туда передается текстовое сообщение "finished", сам System уже сохранен в heap.

### How GC works
С помощью утилиты Visual GC отслеживаем работу сборщика мусора.

По мере работы программы можно увидеть как заполоняется Metaspace (заполняется классами:
JvmComprehension, String,Object,Integer,System).
![VisualGC](src/main/java/Visuial GC1.jpg)
Как данные заполняются в Eden, происходит сбор мусора, при этом происходит 
полная остановка программы (но ее в принципе практически не видно), мертвые объекты (не используемые, на которые нет ссылок, удаляются, а так называемые 
"выжившие данные" переходят в область Survivor 0 или Survivor 1, при этом одна из областей
Survivor 1 или Survivor 0 всегда должна быть пуста. 

![VisualGC](src/main/java/Visuial GC2.jpg)
В итоге, прошедшие несколько циклов сборки мусора и "выжившие объекты"
переходят в Old generation, где проверяются на наличие так называемого "мусора" реже.